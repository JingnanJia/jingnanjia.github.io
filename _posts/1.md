# 1.背包问题

> ## 迭代 递归

### 代码

[背包问题代码](https://github.com/huihut/interview/blob/master/Problems/KnapsackProblem/pack.cpp)

### 问题说明

有N件物品和一个容量为V的背包。

第i件物品的重量是w[i]，价值是v[i]。

求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，

且价值总和最大。

### 功能说明

本程序用**动态规划的思想**解决了背包问题，并用了两种算法： 迭代法、递归法。在迭代法中实现了打印背包问题的表格。

### 代码简述

通过用户输入数据，程序输入检测，动态分配空间，选择算法， 用动态规划的思想求解背包问题。

#### 迭代法：

通过遍历n行W列，迭代每行每列的值，并把最优解放到 n行（在数组中为第n+1行）W列（在数组中为第W+1列）中。

#### 递归法：

通过每次返回前i个物品和承重为j的最优解， 递归计算总背包问题的最优解。

## 思路：

0-1背包问题：在最优解中，每个物品只有两种可能的情况，即在背包中或者不在背包中（背包中的该物品数为0或1），因此称为0-1背包问题。

**步骤1-找子问题：**子问题必然是和物品有关的，对于每一个物品，有两种结果：能装下或者不能装下。第一，包的容量比物品体积小，装不下，这时的最大价值和前i-1个物品的最大价值是一样的。第二，还有足够的容量装下该物品，但是装了不一定大于当前相同体积的最优价值，所以要进行比较。由上述分析，子问题中物品数和背包容量都应当作为变量。因此子问题确定为背包容量为j时，求前i个物品所能达到最大价值。

**步骤2-确定状态：**由上述分析，“状态”对应的“值”即为背包容量为j时，求前i个物品所能达到最大价值，设为dp[i] [j]。初始时，dp[0] [j] (0<=j<=V)为0，没有物品也就没有价值。

**步骤3-确定状态转移方程：**由上述分析，第i个物品的体积为w,价值为v，则状态转移方程为

动态规划方程为：

​			dp[0] [j]=0   //物品数量为0，则总价值为0

​           dp[i] [0]=0   //背包承重为0，则总价值为0

​           dp[i] [j]=dp[i-1] [j]   ,weight[i]>j      //第i个物品的重量大于背包当前的承重j时，则第i个物品不放入背包，总价值为放入前i-1个物品的价值

​           dp[i] [j]=max{dp[i-1] [j], dp[i-1] [j-weight[i]]+value[i]}     ,weight<=j  

​            //即，第i个物品的重量小于等于背包当前的承重j时，这个时候要考虑要不要放入该物品。

​           //不放该物品，前i-1个物品的背包总承重为j；放入该物品，前i-1个物品的背包承重为j-weight[i]，考虑两种情况下谁的总价值最大

### -迭代法求解-

请输入物品数 n (n>=0)  6 请输入背包承重量 W (W>=0)  9 请输入第 1 个物品的重量和价值（用空格隔开） 3 4 请输入第 2 个物品的重量和价值（用空格隔开） 2 3 请输入第 3 个物品的重量和价值（用空格隔开） 5 5 请输入第 4 个物品的重量和价值（用空格隔开） 4 6 请输入第 5 个物品的重量和价值（用空格隔开） 3 2 请输入第 6 个物品的重量和价值（用空格隔开） 3 6 

------------------------------------------------

请选择算法： 

【1】迭代法 【2】递归法

------------------------------------------------

1   能装下物品的最大价值为 15 

------------------------------------------------

- 0:	0	0	0	0	0	0	0	0	0	0	 
- 1:	0	0	0	4	4	4	4	4	4	4	 
- 2:	0	0	3	4	4	7	7	7	7	7	 
- 3:	0	0	3	4	4	7	7	8	9	9	 
- 4:	0	0	3	4	6	7	9	10	10	13	
- 5:	0	0	3	4	6	7	9	10	10	13	 
- 6:	0	0	3	6	6	9	10	12	13	**15**	 

------------------------------------------------

# 2.排序组合问题

> ## 递归

在一系列的集合（不确定，需要动态规划求解，**排序组合N个中选V个**）中，求得价值最大的集合

背包问题-->抽象成数据问题-->排列组合中的组合问题

**公式：**C [n] [m] = C [n-1] [m-1] + C [n-1] [m] ； **边界条件：**C [0] [0] = C [1] [0] = C [1] [1] = 1

组合问题-->可使用动态规划求解。

> 2018年秋招-小Q的歌单



# 3.最大公因数问题

辗转相除法求最大公因数

```C++
int gcd(int x, int y) // x>y
{
    while(y!=0){
        int z = x%y;
        x = y;
        y = z;
    }
    return x;
}
```

